% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ itcp \mbox{}}}\\
\vfill

\hypersetup{pdftitle= itcp }
\markright{\scriptsize \mbox{}\hfill  itcp  \hfill\mbox{}}
{\Huge \textbf{ Information Theoretic Converse Prover \mbox{}}}\\
\vfill

{\Huge  1.0 \mbox{}}\\[1cm]
{ 07/07/2016 \mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Jayant Apte\\
    \mbox{}}}\\
\hypersetup{pdfauthor= Jayant Apte\\
    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Jayant Apte\\
    }  Email: \href{mailto://jayant91089@gmail.com} {\texttt{jayant91089@gmail.com}}\\
  Homepage: \href{https://sites.google.com/site/jayantapteshomepage/} {\texttt{https://sites.google.com/site/jayantapteshomepage/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Department of Electrical and Computer Engineering\\
 Drexel University\\
 Philadelphia, PA 19104\\
 \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 1 ]}}

\tableofcontents
\newpage

 \index{\textsf{itcp}}     
\chapter{\textcolor{Chapter }{Introduction}}\label{Chapter_Introduction}
\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  ITCP stands for Information Theoretic Converse Prover. Several converse
proofs, like those arising in multi-source network coding over directed
acyclic hypergraphs, distributed storage, secret sharing, and graph guessing
games etc., can be divided into two parts: 1) What to prove? 2) How to prove?
ITCP is a software that allows one to use a computer to generate sensible
statements of converse proofs i.e. part 1). The actual proof, i.e. part 2),
can then be generated using Yeung's framework \cite{yeunginfoframework} and linear programming duality (see eg. \cite{lihmsnc}, \cite{TianJSAC433}). Currently, it supports the following types of converse proofs: 
\begin{itemize}
\item  Polyhedral Converse (Network Coding): Given a multi-source network coding
instance, determine the tightest set of inequalities amoungst source rate and
edge capacity variables that are implied by Shannon-type and (if specified)
given non-Shannnon-type information inequalities 
\item  Sum-rate Converse (Network Coding): Given a multi-source network coding
instance, determine the least upper bound on the sum of source rates, implied
by Shannon-type and (if specified) given non-Shannnon-type information
inequalities, under specified edge capacities. 
\item  Worst-case information ratio lower bounds (Secret Sharing): Given an access
structure, determine the greatest lower bound on the workst case information
ratio implied by Shannon-type and (if specified) given non-Shannnon-type
information inequalities 
\item  Guessing Number upper bounds (Guessing Games played on directed graphs): Given
a directed graph, determine the least upper bound on its guessing number
implied by Shannon-type and (if specified) given non-Shannnon-type information
inequalities 
\end{itemize}
 The last three types of converse proofs can be performed by using linear
programming techniques. This involves solving a linear program, whose optimum
value gives us an upper (lower) bound. Then, one uses dual optimal vertex to
provide a human readable proof that tells us how to combine various
information inequalities to arrive at the aforementioned upper (lower) bound.
For the first type of converse proof, however, one requires more sophisticated
tools. For that purpose, ITCP uses polyhedral projection algorithm symchm,
implemented in another GAP package that goes by The same name. In all of the
problems mentioned above, one has to either project or solve linear programs
over polytopes that have exponentially many dimensions compared to the problem
size. A key feature of ITCP is automatic detection of problem symmetries and
symmetry exploitation to reduce the ComplexityOfAlgebra of solving the above
problems, so that one can approach ever larger problems from a computational
perspective. }

   
\chapter{\textcolor{Chapter }{Installation}}\label{Chapter_Installation}
\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X8360C04082558A12}{}
{
  ITCP requires GAP package symchm \cite{jayantsymchm} for symmetry exploiting polyhedral projection, along with package $\texttt{qsopt}\_\texttt{ex-interface}$ for solving linear programs exactly using rational arithmetic. You can find
information about how to install them in their respective user manuals. To get
the newest version of ITCP, download the .zip archive from \href{https://github.com/jayant91089/itcp} {\texttt{https://github.com/jayant91089/itcp}} and unpack it using 
\[\texttt{unzip itcp-x.zip}\]
 Do this preferably inside the $pkg$ subdirectory of your GAP 4 installation. It creates a subdirectory called $itcp$. This completes the installation of the package. If you do not know the
whereabouts of the $pkg$ subdirectory, invoke the following in GAP: 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  GAPInfo.("RootPaths");
\end{Verbatim}
 Look for pkg directory inside any of the paths returned. One can then start
using ITCP by invoking 
\[gap>\]
 
\begin{Verbatim}[fontsize=\small,frame=single,label=Code]
  LoadPackage( "itcp");
\end{Verbatim}
 from within GAP. This would automatically load the dependencies $symchm$ and $\texttt{qsopt}\_\texttt{ex-interface}$, so you don't have to load them seperately. }

   
\chapter{\textcolor{Chapter }{Usage}}\label{Chapter_Usage}
\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X86A9B6F87E619FFF}{}
{
  
\section{\textcolor{Chapter }{Available functions}}\label{Chapter_Usage_Section_Available_functions}
\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X835D65A88292737E}{}
{
  In this section we shall look at the functions provided by ITCP. 

\subsection{\textcolor{Chapter }{NetSymGroup}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X8612CAE37A80ED69}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NetSymGroup({\mdseries\slshape ncinstance})\index{NetSymGroup@\texttt{NetSymGroup}}
\label{NetSymGroup}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A group 



 This function finds the Network Symmetry Group of the input network instance
bounding the rate region of an instance of mult-source network coding on
directed acyclic hypergraphs. It accepts following arguments: 
\begin{itemize}
\item  $ncinstance$ is a list $[cons,nsrc,nvars]$ containing 3 elements: 
\begin{itemize}
\item  $cons$ is a list of network coding constraints. 
\item  $nsrc$ is the number of sources. 
\item  $nvars$ is the number of random variables associated with the network. 
\end{itemize}
 
\end{itemize}
 Returns a subgroup of symmetric group of $nvars$ labels }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@# Define a size 8 IDSC instance|
  !gapprompt@>| !gapinput@idsc:=[ [ [ [ 1, 2, 3 ], [ 1, 2, 3, 4, 5, 6, 7, 8 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 4, 5 ], [ 1, 2, 4, 5 ] ], [ [ 5, 6 ], [ 1, 2, 5, 6 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 6, 7 ], [ 1, 2, 6, 7 ] ], [ [ 7, 8 ], [ 1, 2, 7, 8 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 4, 8 ], [ 1, 2, 4, 8 ] ], [ [ 4, 6 ], [ 3, 4, 6 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 5, 8 ], [ 3, 5, 8 ] ], [ [ 4, 7 ], [ 3, 4, 7 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 5, 7 ], [ 3, 5, 7 ] ], [ [ 6, 8 ], [ 3, 6, 8 ] ] ], 3, 8 ];|
  !gapprompt@gap>| !gapinput@G:=NetSymGroup(idsc);|
  Group([ (5,8)(6,7), (4,5)(6,8), (4,6)(7,8), (1,2) ])
  !gapprompt@gap>| !gapinput@Size(G);|
  20
\end{Verbatim}
 $\textbf{NOTE 1:}$ Certain naming convensions are followed while defining network coding
instances. The source messages are labeled with $[1...nsrc]$ while rest of the messages are labeled $[nsrc...nvars]$. Furthermore, the list $cons$ includes all network constraints except source independence. This constraint
is implied with the labeling i.e. ITAP enforces it by default for the messages
labeled $[1...nsrc]$. 

\subsection{\textcolor{Chapter }{NCRateRegionOB}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X80313471845C1802}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NCRateRegionOB({\mdseries\slshape ncinstance, usesym, optargs})\index{NCRateRegionOB@\texttt{NCRateRegionOB}}
\label{NCRateRegionOB}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A list 



 This function finds the minimal (non-redundant) collection of inequalities
bounding the rate region of an instance of mult-source network coding on
directed acyclic hypergraphs. It accepts following arguments: 
\begin{itemize}
\item  $ncinstance$ is a list $[cons,nsrc,nvars]$ containing 3 elements: 
\begin{itemize}
\item  $cons$ is a list of network coding constraints. 
\item  $nsrc$ is the number of sources. 
\item  $nvars$ is the number of random variables associated with the network. 
\end{itemize}
 
\item  $usesym$ is a boolean indicating whether symmetry should be used in computation 
\item  $optargs$ is a list of optional arguments $[nsrec,..]$ where $nsrec$, when specified, is a GAP record that specifies any non-Shannon type
information inequalities to be included in the computation. 
\end{itemize}
 Returns a list $[rr,rrstring]$ where $rr$ is a list of normal vectors of the inequalities bounding the rate region, that
are inequivalent under the Network Symmetry Group of $ncinstance$ if $usesym$ is true, otherwise $rr$ contains all such normal vectors, under assumption of no symmetries. $rrstring$ is a string that can be used to display inequalities associated with $rr$ in an easier to read format. }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@# define a network instance (in this case, Fano network)|
  !gapprompt@>| !gapinput@F:=[ [ [ [ 1, 2 ], [ 1, 2, 4 ] ], [ [ 2, 3 ], [ 2, 3, 5 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 4, 5 ], [ 4, 5, 6 ] ], [ [ 3, 4 ], [ 3, 4, 7 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 1, 6 ], [ 3, 1, 6 ] ], [ [ 6, 7 ], [ 2, 6, 7 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 5, 7 ], [ 1, 5, 7 ] ] ], 3, 7 ];;|
  !gapprompt@gap>| !gapinput@rlist:=NCRateRegionOB(F,true,[]);;|
  !gapprompt@gap>| !gapinput@Display(rlist[2]);|
  0 >= -w2
  0 >= -w1
  0 >= -w3
  +R6 >= +w3
  +R5 >= +w3
  +R7 >= +w1
  +R4 >= +w1
  +R6 +R7 >= +w2 +w3
  +R4 +R6 >= +w2 +w3
  +R4 +R5 >= +w2 +w3
  +R6 +R7 >= +w1 +w2
  +R4 +R6 >= +w1 +w2
  +R4 +R5 >= +w1 +w2
  !gapprompt@gap>| !gapinput@# Define a size 8 IDSC instance with NSG isomorphic to S2 X D5|
  !gapprompt@>| !gapinput@idsc:=[ [ [ [ 1, 2, 3 ], [ 1, 2, 3, 4, 5, 6, 7, 8 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 4, 5 ], [ 1, 2, 4, 5 ] ], [ [ 5, 6 ], [ 1, 2, 5, 6 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 6, 7 ], [ 1, 2, 6, 7 ] ], [ [ 7, 8 ], [ 1, 2, 7, 8 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 4, 8 ], [ 1, 2, 4, 8 ] ], [ [ 4, 6 ], [ 3, 4, 6 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 5, 8 ], [ 3, 5, 8 ] ], [ [ 4, 7 ], [ 3, 4, 7 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 5, 7 ], [ 3, 5, 7 ] ], [ [ 6, 8 ], [ 3, 6, 8 ] ] ], 3, 8 ];|
  !gapprompt@gap>| !gapinput@rlist1:=NCRateRegionOB2(idsc,true,[]);;|
  !gapprompt@gap>| !gapinput@Display(rlist1[2]);|
  0 >= -w2
  0 >= -w3
  +R4 >= 0
  +R4 +R6 >= +w3
  +R4 +R5 >= +w1 +w2
  +R4 +1/2R5 +1/2R8 >= +w1 +w2 +1/2w3
  +1/2R4 +1/2R5 +1/2R6 +1/2R7 >= +w1 +w2 +1/2w3
  +2/3R4 +2/3R5 +1/3R6 +1/3R8 >= +w1 +w2 +2/3w3
  +2/3R4 +1/3R5 +1/3R6 +1/3R7 +1/3R8 >= +w1 +w2 +2/3w3
  +1/2R4 +1/2R5 +1/2R6 +1/4R7 +1/4R8 >= +w1 +w2 +3/4w3
  +R4 +1/2R5 +1/2R6 +1/2R7 >= +w1 +w2 +w3
  +R4 +1/2R5 +1/2R6 +1/2R8 >= +w1 +w2 +w3
  +R4 +1/3R5 +1/3R6 +1/3R7 +1/3R8 >= +w1 +w2 +w3
  +2/3R4 +2/3R5 +1/3R6 +2/3R7 +1/3R8 >= +w1 +w2 +4/3w3
  +R4 +1/2R5 +1/2R6 +R7 >= +w1 +w2 +3/2w3
  +R4 +1/2R5 +1/2R6 +1/2R7 +1/2R8 >= +w1 +w2 +3/2w3
  +2R4 +R6 +R7 >= +w1 +w2 +2w3
  +R4 +R5 +R6 +R7 >= +w1 +w2 +2w3
\end{Verbatim}
 $\textbf{NOTE 2:}$ Currently ITCP supports specifiation of non-Shannon ineqality of Zhang and
Yeung \cite{zyineq97} and 214 new non-Shannon inequalities found by Dougherty, Freiling and Zeger \cite{dfznonshannon}. These inequalities can be applied to any collection of 4 subsets of a given
set of random variables. The keys of the record $nsrec$ can be integers $1,...,215$ where index $1$ corresponds to the ZY inequality while $2,...,215$ correspond to the inequalities found by Dougherty, Freiling and Zeger. The
value associated wth each key is a list of 4-subsets of subsets of $nvars$ random variables associated with the network. Internally, several permuted
forms of these inequalities are created, so as to not break the symmetries of
the network coding instance, that are exploited during the computation. 

\subsection{\textcolor{Chapter }{NCSumRateUB}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X7FB28EC487F9B726}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NCSumRateUB({\mdseries\slshape ncinstance, caps, optargs})\index{NCSumRateUB@\texttt{NCSumRateUB}}
\label{NCSumRateUB}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A rational number 



 This function finds least upper bound on the sum of all source rates that is
implied by the Shannon-type and (if specified) the non-Shannon-type
inequalities. It accepts following arguments: 
\begin{itemize}
\item  $ncinstance$ is a list $[cons,nsrc,nvars]$ containing 3 elements: 
\begin{itemize}
\item  $cons$ is a list of network coding constraints. 
\item  $nsrc$ is the number of sources. 
\item  $nvars$ is the number of random variables associated with the network. 
\end{itemize}
 
\item  $caps$ is a list of $nvars-nsrc$ non-negative integers, specifying the capacity of the edges 
\item  $optargs$ is a list of optional arguments $[nsrec,..]$ where $nsrec$, when specified, is a GAP record that specifies any non-Shannon type
information inequalities to be included in the computation (see NOTE 2 for
explanation of the format). 
\end{itemize}
 Returns a rational number specifying the upper bound }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@# define a network instance|
  !gapprompt@>| !gapinput@N:= [[ [ [ 1 ], [ 1, 3 ] ], [ [ 1 ], [ 1, 4 ] ],[ [ 1, 2, 5 ],\|
  !gapprompt@>| !gapinput@      [ 1, 2 ] ],[ [ 1, 2, 3 ], [ 2, 3 ] ],[ [ 2, 4 ], [ 1, 2, 4 ] ],\|
  !gapprompt@>| !gapinput@      [ [ 2, 3, 4, 5 ], [ 3, 4, 5 ] ]] , 2, 5 ];;|
  !gapprompt@gap>| !gapinput@ub:=NCSumRateUB(N,[1,1,1],[]);;|
  Original LP dimension...28
  LP dimension after considering symmetries...22
  !gapprompt@gap>| !gapinput@ub;|
  2
\end{Verbatim}
 

\subsection{\textcolor{Chapter }{SSWorstInfoRatioLB}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X7E814076838B30E8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SSWorstInfoRatioLB({\mdseries\slshape Asets, nvars, optargs})\index{SSWorstInfoRatioLB@\texttt{SSWorstInfoRatioLB}}
\label{SSWorstInfoRatioLB}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A rational number specifying the lower bound 



 This function finds the greatest lower bound on the worst case information
ratio of a secret sharing instance. 
\begin{itemize}
\item  $Asets$ - A list of authorized sets each specified as a subset of $[nvars-1]$ 
\item  $nvars$ - Number of participants (including one dealer) 
\item  $optargs$ is a list of optional arguments $[nsrec,..]$ where $nsrec$, when specified, is a GAP record that specifies 
\end{itemize}
 any non-Shannon type information inequalities to be included in the
computation (see NOTE 2 for explanation of the format). Returns a rational
number }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@# define an access structure|
  !gapprompt@>| !gapinput@Asets:=[[2,3],[3,4],[4,5]];;|
  !gapprompt@gap>| !gapinput@lb:=SSWorstInfoRatioLB(Asets,5,[]);;|
  Original LP dimension...20
  LP dimension after considering symmetries...12
  !gapprompt@gap>| !gapinput@lb;|
  3/2
\end{Verbatim}
 $\textbf{NOTE 3:}$ No input checking is performed to verify if input $Asets$ follows labeling convensions. 

\subsection{\textcolor{Chapter }{GGnumberUB}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X798F99DF78E91283}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{GGnumberUB({\mdseries\slshape Asets, nvars, optargs})\index{GGnumberUB@\texttt{GGnumberUB}}
\label{GGnumberUB}
}\hfill{\scriptsize (function)}}\\
\textbf{\indent Returns:\ }
A rational number specifying the upper bound 



 This function finds the least upper bound on the guessing number of a directed
graph. 
\begin{itemize}
\item  $G$ - A list with 2 elements: 1) a list of vertices 2) a GAP record each vertex of
the graph to a a list neighbors with edges incoming to it 
\item  $optargs$ is a list of optional arguments $[nsrec,..]$ where $nsrec$, when specified, is a GAP record that specifies 
\end{itemize}
 any non-Shannon type information inequalities to be included in the
computation (see NOTE 2 for explanation of the format). Returns A rational
number }

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@# define a directed graph (in this case, the cycle graph C5)|
  !gapprompt@>| !gapinput@C5:=[ [ 1, 2, 3, 4, 5 ],\|
  !gapprompt@>| !gapinput@  rec( 1 := [ 2, 5 ], 2 := [ 1, 3 ], 3 := [ 2, 4 ],\|
  !gapprompt@>| !gapinput@      4 := [ 3, 5 ], 5 := [ 4, 1 ] ) ];;|
  !gapprompt@gap>| !gapinput@ub:=GGnumberUB(C5,[]);;|
  Original LP dimension...25
  LP dimension after considering symmetries...5
  !gapprompt@gap>| !gapinput@ub;|
  5/2
\end{Verbatim}
 $\textbf{NOTE 4:}$ Certain naming convensions are followed while graph $G$. The vertices are labeled by the set $\{1,...,n\}$ where $n$ is the number of vertices of the graph. Hence, the keys of the record $G$ are integers $\{1,...,n\}$. The value for a key $t$ is a list $[i,j,...]$ where $i,j,...$ are verties s.t. $(i,t),(j,t),...$ are the directed edges of the graph. }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{itcp.bib}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
